{# SPDX-License-Identifier: MIT #}
{# Copyright © 2023 André Santos #}

{##############################################################################}
{# RENDERED CODE #}
{##############################################################################}

# SPDX-License-Identifier: MIT
# Copyright © 2023 André Santos

###############################################################################
# Imports
###############################################################################

from collections import deque, namedtuple
from functools import partial
from math import (
    acos,
    asin,
    atan,
    atan2,
    ceil,
    cos,
    degrees,
    e as E,
    floor,
    log,
    log10,
    pi as PI,
    radians,
    sin,
    sqrt,
    tan,
)
import sys
from threading import Lock

import rclpy
from rclpy.node import Node
from rclpy.qos import DurabilityPolicy, HistoryPolicy, QoSProfile
{% for rospkg in ros_imports %}
import {{ rospkg }}.msg as {{ rospkg }}
{% endfor %}

###############################################################################
# Constants and Data Structures
###############################################################################

INF = float("inf")
NAN = float("nan")

MsgRecord = namedtuple('MsgRecord', ('topic', 'timestamp', 'msg'))


###############################################################################
# Helper Functions
###############################################################################


def prod(iterable):
    x = 1
    for y in iterable:
        x = x * y
        if x == 0:
            return 0
    return x


###############################################################################
# Monitor Classes
###############################################################################


{{ monitor_classes|join('\n\n\n') }}


###############################################################################
# ROS Node
###############################################################################


class HplMonitorNode(Node):
    def __init__(self):
        super().__init__('hplrv_monitor')
        self.monitors = [
            {# -#}
        {% for cname in class_names %}
            {{ cname }}(),
        {% endfor %}
        ]
        self.timer = self.create_timer(0.01, self.on_timer)
        latching_qos = QoSProfile(
            depth=1,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
            history=HistoryPolicy.KEEP_LAST,
        )
        self.pubs = []
        for i in range(len(self.monitors)):
            mon = self.monitors[i]
            pub = self.create_publisher(std_msgs.Bool, f'~p{i}/verdict', latching_qos)
            self.pubs.append(pub)
            mon.on_success = partial(self._on_success, i)
            mon.on_violation = partial(self._on_failure, i)
        self.subs = [
            {# -#}
        {% for topic, typename in topics.items() %}
            self.create_subscription(
                {{ typename|replace('/', '.') }},
                '{{ topic }}',
                self.on_msg_{{ topic|replace('/', '_') }},
                10,
            ),
        {% endfor %}
        ]

    def on_launch(self):
        t = self.get_clock().now()
        for mon in self.monitors:
            mon.on_launch(t)

    def on_shutdown(self):
        t = self.get_clock().now()
        for mon in self.monitors:
            mon.on_shutdown(t)

    def on_timer(self):
        t = self.get_clock().now()
        for mon in self.monitors:
            mon.on_timer(t)
    {# -#}
{% for topic, indices in callbacks.items() %}

    {% set cbname = 'on_msg_' ~ topic.replace('/', '_') %}
    def {{ cbname }}(self, msg):
        t = self.get_clock().now()
        {% for i in indices %}
        self.monitors[{{ i }}].{{ cbname }}(msg, t)
        {% endfor %}
{% endfor %}

    def _on_success(self, i, _stamp, _witness):
        mon = self.monitors[i]
        assert mon.verdict is True
        self.pubs[i].publish(True)

    def _on_failure(self, i, _stamp, _witness):
        mon = self.monitors[i]
        assert mon.verdict is False
        self.pubs[i].publish(False)


def main(args=None):
    rclpy.init(args=args)
    node = HplMonitorNode()
    node.on_launch()
    # Docs for spin_once:
    # https://docs.ros.org/en/ros2_packages/rolling/api/rclpy/api/init_shutdown.html#rclpy.spin_once
    rclpy.spin(node)
    node.on_shutdown()
    # Destroy the node explicitly
    # (optional - otherwise it will be done automatically
    # when the garbage collector destroys the node object)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == "__main__":
    main(args=sys.argv[1:])
